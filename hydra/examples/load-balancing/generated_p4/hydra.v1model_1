header eth_type2_t {
  bit<16> value;
}
header variables_t {
  
}
header left_loads_preamble_t {
  bit<8> num_items_left_loads;
}
header left_loads_item_t {
  bit<32> value;
}
header right_loads_preamble_t {
  bit<8> num_items_right_loads;
}
header right_loads_item_t {
  bit<32> value;
}
struct hydra_header_t {
  eth_type2_t eth_type;
  variables_t variables;
  hops_preamble_t hops_preamble;
  hops_item_t[4] hops;
  left_loads_preamble_t left_loads_preamble;
  left_loads_item_t[4] left_loads;
  right_loads_preamble_t right_loads_preamble;
  right_loads_item_t[4] right_loads;
}
struct hydra_metadata_t {
  bit<8> num_list_items;
}
parser CheckerHeaderParser(packet_in packet, out hydra_header_t hydra_header,
                           inout hydra_metadata_t hydra_metadata) {
  state parse_eth_type {
    packet.extract(hydra_header.eth_type);
    transition parse_variables;
  }
  state parse_variables {
    packet.extract(hydra_header.variables);
    transition parse_hops_preamble;
  }
  state parse_hops_preamble
    {
    packet.extract(hydra_header.hops_preamble);
    hydra_metadata.num_list_items =
    hydra_header.hops_preamble.num_hops_items;
    transition select(hydra_metadata.num_list_items) {
      0: parse_left_loads_preamble;
      default: parse_hops;
    }
  }
  state parse_left_loads_preamble
    {
    packet.extract(hydra_header.left_loads_preamble);
    hydra_metadata.num_list_items =
    hydra_header.left_loads_preamble.num_left_loads_items;
    transition select(hydra_metadata.num_list_items) {
      0: parse_right_loads_preamble;
      default: parse_left_loads;
    }
  }
  state parse_right_loads_preamble
    {
    packet.extract(hydra_header.right_loads_preamble);
    hydra_metadata.num_list_items =
    hydra_header.right_loads_preamble.num_right_loads_items;
    transition select(hydra_metadata.num_list_items) {
      0: accept;
      default: parse_right_loads;
    }
  }
  state parse_hops
    {
    packet.extract(hydra_header.hops.next);
    hydra_metadata.num_list_items = hydra_metadata.num_list_items-1;
    transition select(hydra_metadata.num_list_items) {
      0: parse_left_loads_preamble;
      default: parse_hops;
    }
  }
  state parse_left_loads
    {
    packet.extract(hydra_header.left_loads.next);
    hydra_metadata.num_list_items = hydra_metadata.num_list_items-1;
    transition select(hydra_metadata.num_list_items) {
      0: parse_right_loads_preamble;
      default: parse_left_loads;
    }
  }
  state parse_right_loads
    {
    packet.extract(hydra_header.right_loads.next);
    hydra_metadata.num_list_items = hydra_metadata.num_list_items-1;
    transition select(hydra_metadata.num_list_items) {
      0: accept;
      default: parse_right_loads;
    }
  }
}
control CheckerHeaderDeparser(packet_out packet,
                              out hydra_header_t hydra_header) {
  apply
    {
    packet.emit(hydra_header.eth_type);
    packet.emit(hydra_header.variables);
    packet.emit(hydra_header.hops_preamble);
    packet.emit(hydra_header.hops);
    packet.emit(hydra_header.left_loads_preamble);
    packet.emit(hydra_header.left_loads);
    packet.emit(hydra_header.right_loads_preamble);
    packet.emit(hydra_header.right_loads);
  }
}
control initControl(in ingress_headers_t hdr,
                    inout checker_header_t checker_header,
                    inout checker_metadata_t checker_metadata) {
  action init_cp_vars(bit<8> left_port, bit<8> right_port, bit<32> thresh)
    {
    checker_metadata.variables.left_port = left_port;
    checker_metadata.variables.right_port = right_port;
    checker_metadata.variables.thresh = thresh;
  }
  table tb_init_cp_vars {
    key = {
      
    }
    actions = {
      init_cp_vars;
    }
    size = 2;
  }
  apply
    {
    tb_init_cp_vars.apply();
    hydra_header.eth_type.setValid();
    hydra_header.eth_type.value = ETHERTYPE_CHECKER;
    hydra_header.checker_header_types.setValid();
    hydra_header.hydra_header_types.variables = 1w1;
    hydra_header.variables.setValid();
    hydra_header.variables.left_loads = 0;
    hydra_header.variables.right_loads = 0;
    left_load = 0;
    right_load = 0;
  }
}
control telemetryControl(in ingress_headers_t hdr,
                         inout checker_header_t checker_header,
                         inout checker_metadata_t checker_metadata) {
  action init_cp_vars(bit<8> left_port, bit<8> right_port, bit<32> thresh)
    {
    checker_metadata.variables.left_port = left_port;
    checker_metadata.variables.right_port = right_port;
    checker_metadata.variables.thresh = thresh;
  }
  table tb_init_cp_vars {
    key = {
      
    }
    actions = {
      init_cp_vars;
    }
    size = 2;
  }
  action lkp_cp_dict_is_uplink(bool is_uplink)
    {
    checker_metadata.is_uplink = is_uplink;
  }
  table tbl_lkp_cp_dict_is_uplink
    {
    key = {
      standard_metadata.is_uplink_var0: exact;
    }
    actions = {
      lkp_cp_dict_is_uplink;
    }
    size = 64;
  }
  apply
    {
    tb_init_cp_vars.apply();
    hydra_metadata.is_uplink_var0 = hydra_header.variables.eg_port;
    tb_lkp_cp_dict_is_uplink.apply();
    if (hydra_metadata.is_uplink)
      {
      if (@standard_metadata.egress_port.eg_port==hydra_metadata.left_port)
        {
        left_load =
        hydra_sensor.left_load+@standard_metadata.packet_length.packet_len;
      }else
      {
      if (@standard_metadata.egress_port.eg_port==hydra_metadata.right_port)
        {
        right_load =
        hydra_sensor.right_load+@standard_metadata.packet_length.packet_len;
      }
      }
    }
    hydra_header.left_loadss.push_front(1);
    hydra_header.left_loadss[0].setValid();
    hydra_header.left_loadss[0].left_loads = hydra_sensor.left_load;
    hydra_header.right_loadss.push_front(1);
    hydra_header.right_loadss[0].setValid();
    hydra_header.right_loadss[0].right_loads = hydra_sensor.right_load;
  }
}
control checkerControl(in ingress_headers_t hdr,
                       inout checker_header_t checker_header,
                       inout checker_metadata_t checker_metadata) {
  action init_cp_vars(bit<8> left_port, bit<8> right_port, bit<32> thresh)
    {
    checker_metadata.variables.left_port = left_port;
    checker_metadata.variables.right_port = right_port;
    checker_metadata.variables.thresh = thresh;
  }
  table tb_init_cp_vars {
    key = {
      
    }
    actions = {
      init_cp_vars;
    }
    size = 2;
  }
  apply
    {
    tb_init_cp_vars.apply();
    hydra_header.eth_typ.setInvalid();
    hydra_header.hydra_header_types.setInvalid();
    hydra_header.hops_preamble.setInvalid();
    hydra_header.variables.setInvalid();
    bit<32> l_load;
    bit<32> r_load;
    if
      (hydra_header.left_loads[0].isValid() && hydra_header.right_loads[0].isValid())
      {
      l_load = hydra_header.left_loads[0];
      r_load = hydra_header.right_loads[0];
      bit<32> diff = l_load-r_load;
      if
        (l_load<r_load && ~diff>hydra_metadata.thresh || l_load>=r_load && diff>hydra_metadata.thresh)
        {
        checker_metadata.reject0 = true;
      }
      if
        (hydra_header.left_loads[1].isValid() && hydra_header.right_loads[1].isValid())
        {
        l_load = hydra_header.left_loads[1];
        r_load = hydra_header.right_loads[1];
        bit<32> diff = l_load-r_load;
        if
          (l_load<r_load && ~diff>hydra_metadata.thresh || l_load>=r_load && diff>hydra_metadata.thresh)
          {
          checker_metadata.reject0 = true;
        }
        if
          (hydra_header.left_loads[2].isValid() && hydra_header.right_loads[2].isValid())
          {
          l_load = hydra_header.left_loads[2];
          r_load = hydra_header.right_loads[2];
          bit<32> diff = l_load-r_load;
          if
            (l_load<r_load && ~diff>hydra_metadata.thresh || l_load>=r_load && diff>hydra_metadata.thresh)
            {
            checker_metadata.reject0 = true;
          }
          if
            (hydra_header.left_loads[3].isValid() && hydra_header.right_loads[3].isValid())
            {
            l_load = hydra_header.left_loads[3];
            r_load = hydra_header.right_loads[3];
            bit<32> diff = l_load-r_load;
            if
              (l_load<r_load && ~diff>hydra_metadata.thresh || l_load>=r_load && diff>hydra_metadata.thresh)
              {
              checker_metadata.reject0 = true;
            }
          }
        }
      }
    }
  }
}

